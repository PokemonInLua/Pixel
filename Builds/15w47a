

--[[
	Name: Pixel
	Author: Wassil Janssen a.k.a. Creator
	Licence: GNU GENERAL PUBLIC LICENSE
	Description: A GUI library specifically written for ComputerCraft
]]--

--[[
	Name: Application
	Author: Wassil Janssen a.k.a. Creator
	Licence: GNU GENERAL PUBLIC LICENSE
	Description: An application holder for Pixel.
]]--

function Application(parameters)
	--Private
	local threads = {}
	local screens = {}
	local term_events = {
		["key"] = true,
		["mouse_click"] = true,
		["paste"] = true,
		["char"] = true,
		["mouse_scroll"] = true,
		["mouse_drag"] = true,
		["key_up"] = true,
		["mouse_up"] = true
	}
	local run = true
	local function runThreads(event)
		for i,v in pairs(threads) do
			coroutine.resume(v,unpack(event))
			coroutine.status(v)
		end
	end
	
	--Public
	local self = {}
	self.type = "Application"
	function self.event(event)
		if event[1] == "monitor_touch" then
			if screens[event[2]] then 
				screens[event[2]].event(event)
			end
		elseif term_events[event[1]] then
			if screens.term then
				screens.term.event(event)
			end
		elseif event[1] == "terminate" then
			--complicated
		else
			for i,v in pairs(screens) do
				v.event(event)
			end
		end
		runThreads(event)
	end
	function self.run(terminate)
		run = true
		self.draw()
		local self_event = self.event
		if terminate then
			while run do
				local event = {coroutine.yield()}
				if event[1] == terminate then
					break
				end
				self_event(event)
			end
		else
			while run do
				local event = {coroutine.yield()}
				self_event(event)
			end
		end
	end
	function self.addScreen(destination,scr)
		if destination == "term" then
			screens[destination] = scr
			screens[destination].setParent(term.native())
			screens[destination].runThreads(runThreads)
			screens[destination].setApplication()
		elseif peripheral.isPresent(destination) then
			screens[destination] = scr
			screens[destination].setParent(peripheral.wrap(destination))
			screens[destination].runThreads(runThreads)
			screens[destination].setApplication()
		else
			return false, "Peripheral is not present!"
		end
	end
	function self.set(tabl)
		if tabl.threads then
			for i,v in pairs(tabl.threads) do
				self.addThread(v)
			end
		end
		if tabl.screens then
			for i,v in pairs(tabl.screens) do
				self.addScreen(v)
			end
		end
	end
	function self.get()
		return {
			threads = threads,
			screens = screens,
		}
	end
	function self.addThread(th)
		if type(th) == "thread" then
			threads[#threads+1] = th
		elseif type(th) == "function" then
			local th = coroutine.create(th)
			threads[#threads+1] = th
		else
			return false, "You have to provide a thread or a function."
		end
	end
	function self.quit()
		run = false
	end
	function self.draw()
		for i,v in pairs(screens) do
			v.draw()
		end
	end
	--Constructor
	self.set(parameters or {})

	--Final stage
	return self
end

--[[
	Name: Button
	Author: Wassil Janssen a.k.a. Creator
	Licence: GNU GENERAL PUBLIC LICENSE
	Description: The button module
]]--

function Button(parameters)
	--Private--
	local x = x or 1
	local y = y or 1
	local width = width or 11
	local height = height or 3
	local xText = xText or 2
	local yText = yText or 2
	local text = text or "I, button"
	local fg = fg or colors.black
	local bg = bg or colors.white
	local fgOnPress = fgOnPress or colors.white
	local bgOnPress = bgOnPress or colors.black
	local onRightClick = onRightClick or function()end
	local onLeftClick = onLeftClick or function()end
	local xOffset = 0
	local yOffset = 0
	local finalX = xOffset + x
	local finalY = yOffset + y
	local parent = {}
	local application = {}

	--Public--
	local self = {}
	function self.draw(isPressed)
		if (finalX <= 51 or finalX+width-1 >= 1) and (finalY <= 51 or finalY+height-1 >= 1) then
			paintutils.drawFilledBox(finalX,finalY,finalX+width-1,finalY+height-1,isPressed and bgOnPress or bg)
			term.setCursorPos(finalX+xText-1,finalY+yText-1)
			term.setTextColor(isPressed and fgOnPress or fg)
			term.write(text)
		end
	end
	function self.move(xNew,yNew)
		x = xNew
		y = yNew
		finalX = xOffset + x
		finalY = yOffset + y
	end
	function self.resize(w,h)
		width = w
		height = h
	end
	function self.get(ser)
		return {
			x = x,
			y = y,
			width = width,
			height = height,
			xText = xText,
			yText = yText,
			text = text,
			fg = fg,
			bg = bg,
			fgOnPress = fgOnPress,
			bgOnPress = bgOnPress,
		}
	end
	function self.set(targs)
		x = targs.x or x
		y = targs.y or y
		width = targs.width or width
		height = targs.height or height
		xText = targs.xText or xText
		yText = targs.yText or yText
		text = targs.text or text
		fg = targs.fg or fg
		bg = targs.bg or bg
		fgOnPress = targs.fgOnPress or fgOnPress
		bgOnPress = targs.bgOnPress or bgOnPress
		onRightClick = targs.onRightClick or onRightClick
		onLeftClick = targs.onLeftClick or onLeftClick
		finalX = xOffset + x
		finalY = yOffset + y
	end
	function self.setOffset(xOffsetT,yOffsetT)
		xOffset = xOffsetT
		yOffset = yOffsetT
		finalX = xOffset + x
		finalY = yOffset + y
	end
	function self.event(e)
		if e[1] == "mouse_click" then
			if finalX <= e[3] and e[3] <= finalX+width-1 and finalY <= e[4] and e[4] <= finalY+height-1 then
				if e[2] == 1 then
					self.draw(true)
					onLeftClick(self,e)
				elseif e[2] == 2 then
					self.draw(true)
					onRightClick(self,e)
				end
			end
		end
	end
	self.type = "Button"
	self.canRun = false
	function self.setParent(par)
		parent = par
	end
	function self.callParent(method,...)
		if parent[method] then
			parent[method](...)
		end
	end
	function self.callApplication(method,...)
		if application[method] then
			application[method](...)
		end
	end
	function self.setApplication(app)
		application = app
	end
	function self.setBindings(bin)
		bindings = bin
	end
	--Constructor
	self.set(parameters)
	return self
end





--[[
	Name: Image
	Author: Wassil Janssen a.k.a. Creator
	Licence: GNU GENERAL PUBLIC LICENSE
	Description: An image drawer
]]--

function Image()
	--Private
	local x = x or 1
	local y = y or 1
	local xOffset = 0
	local yOffset = 0
	local finalX = xOffset + x
	local finalY = yOffset + y
	local data = fs.exists(path) and paintutils.loadImage(path) or {{16384}}
	--Public
	local self = {}
	function self.draw()
		paintutils.drawImage(data,finalX,finalY)
	end
	function self.move(xNew,yNew)
		x = xNew
		y = yNew
		finalX = xOffset + x
		finalY = yOffset + y
	end
	function self.get(ser)
		return {
			x = x,
			y = y,
			text = text,
			textColor = textColor,
			bgColor = bgColor,
		}
	end
	function self.set(targs)
		x = targs.x or x
		y = targs.y or y
		text = targs.text or text
		textColor = targs.textColor or textColor
		bgColor = targs.bgColor or bgColor
		finalX = xOffset + x
		finalY = yOffset + y
	end
	function self.setOffset(xOffsetT,yOffsetT)
		xOffset = xOffsetT
		yOffset = yOffsetT
		finalX = xOffset + x
		finalY = yOffset + y
	end
	function self.getType()
		return "Image"
	end
	function self.event(...)

	end
	return self
end

KeyCodes = {	
	[ 2 ] =  1,
	[ 3 ] =  2,
	[ 4 ] =  3,
	[ 5 ] =  4,
	[ 6 ] =  5,
	[ 7 ] =  6,
	[ 8 ] =  7,
	[ 9 ] =  8,
	[ 10 ] =  9,
	[ 11 ] =  0,
	[ 12 ] = "-",
	[ 13 ] = "=",
	[ 14 ] = "Backspace",
	[ 15 ] = "Tab",
	[ 16 ] = "Q",
	[ 17 ] = "W",
	[ 18 ] = "E",
	[ 19 ] = "R",
	[ 20 ] = "T",
	[ 21 ] = "Y",
	[ 22 ] = "U",
	[ 23 ] = "I",
	[ 24 ] = "O",
	[ 25 ] = "P",
	[ 26 ] = "LeftBracket",
	[ 27 ] = "RightBracket",
	[ 28 ] = "Enter",
	[ 29 ] = "LeftControl",
	[ 30 ] = "A",
	[ 31 ] = "S",
	[ 32 ] = "D",
	[ 33 ] = "F",
	[ 34 ] = "G",
	[ 35 ] = "H",
	[ 36 ] = "J",
	[ 37 ] = "K",
	[ 38 ] = "L",
	[ 39 ] = ";",
	[ 40 ] = "\'",
	[ 41 ] = "`",
	[ 42 ] = "LeftShift",
	[ 43 ] = "Backslash",
	[ 44 ] = "Z",
	[ 45 ] = "X",
	[ 46 ] = "C",
	[ 47 ] = "V",
	[ 48 ] = "B",
	[ 49 ] = "N",
	[ 50 ] = "M",
	[ 51 ] = ",",
	[ 52 ] = ".",
	[ 53 ] = "/",
	[ 54 ] = "RightShift",
	[ 55 ] = "*",
	[ 56 ] = "LeftAlt",
	[ 57 ] = " ",
	[ 58 ] = "CapsLock",
	[ 59 ] = "F1",
	[ 60 ] = "F2",
	[ 61 ] = "F3",
	[ 62 ] = "F4",
	[ 63 ] = "F5",
	[ 64 ] = "F6",
	[ 65 ] = "F7",
	[ 66 ] =  "F8",
	[ 67 ] =  "F9",
	[ 68 ] =  "F10",
	[ 69 ] = "NumberLock",
	[ 70 ] = "ScrollLock",
	[ 71 ] = "NumPAd7",
	[ 72 ] = "NumPAd8",
	[ 73 ] = "NumPAd9",
	[ 74 ] = "Substract",
	[ 75 ] = "NumPAd4",
	[ 76 ] = "NumPAd5",
	[ 77 ] = "NumPAd6",
	[ 78 ] = "Add",
	[ 79 ] = "NumPAd1",
	[ 80 ] = "NumPAd2",
	[ 81 ] = "NumPAd3",
	[ 82 ] = "NumPAd0",
	[ 83 ] = "Decimal",
	[ 87 ] = "F11",
	[ 88 ] = "F12",
	[ 100 ] = "F13",
	[ 101 ] = "F14",
	[ 102 ] = "F15",
	[ 103 ] = "F16",
	[ 104 ] = "F17",
	[ 105 ] = "F18",
	[ 112 ] = "Kana",
	[ 113 ] = "F19",
	[ 121 ] = "Convert",
	[ 123 ] = "Noconvert",
	[ 125 ] = "Yen",
	[ 141 ] = "NumPadEquals",
	[ 144 ] = "^",
	[ 145 ] = "@",
	[ 146 ] = ":",
	[ 147 ] = "_",
	[ 148 ] = "Kanji",
	[ 149 ] = "Stop",
	[ 150 ] = "Ax",
	[ 151 ] = "Unlabeled",
	[ 156 ] = "NumPadEnter",
	[ 157 ] = "RightControl",
	[ 157 ] = "Section",
	[ 179 ] = "NumPadComma",
	[ 181 ] = "Dvide",
	[ 183 ] = "Sysrq",
	[ 184 ] = "RightAlt",
	[ 196 ] = "Function",
	[ 197 ] = "Pause",
	[ 199 ] = "Home",
	[ 200 ] = "Up",
	[ 201 ] = "PageUp",
	[ 203 ] = "Left",
	[ 205 ] = "Right",
	[ 207 ] = "End",
	[ 208 ] = "Down",
	[ 209 ] = "PageDown",
	[ 210 ] = "Insert",
	[ 211 ] = "Delete",
}

--[[
	Name: Label
	Author: Wassil Janssen a.k.a. Creator
	Licence: GNU GENERAL PUBLIC LICENSE
	Description: Label class
]]--

function Label(x,y,text,textColor,backgroundColor)
	--Private
	local text = text or ""
	local textColor = textColor or colors.white
	local backgroundColor = backgroundColor or colors.black
	local x = x or 1
	local y = y or 1
	local xOffset = 0
	local yOffset = 0
	local finalX = xOffset + x
	local finalY = yOffset + y
	--Public
	local self = {}
	function self.draw(isPressed)
		term.setCursorPos(finalX,finalY)
		term.setBackgroundColor(backgroundColor)
		term.setTextColor(textColor)
		term.write(text)
	end
	function self.move(xNew,yNew)
		x = xNew
		y = yNew
		finalX = xOffset + x
		finalY = yOffset + y
	end
	function self.get(ser)
		return {
			x = x,
			y = y,
			text = text,
			textColor = textColor,
			backgroundColor = backgroundColor,
		}
	end
	function self.set(targs)
		x = targs.x or x
		y = targs.y or y
		text = targs.text or text
		textColor = targs.textColor or textColor
		backgroundColor = targs.backgroundColor or backgroundColor
		finalX = xOffset + x
		finalY = yOffset + y
	end
	function self.setOffset(xOffsetT,yOffsetT)
		xOffset = xOffsetT
		yOffset = yOffsetT
		finalX = xOffset + x
		finalY = yOffset + y
	end
	self.type = "Label"
	function self.event(...)

	end
	return self
end

--[[
	Name: Layout
	Author: Wassil Janssen a.k.a. Creator
	Licence: GNU GENERAL PUBLIC LICENSE
	Description: A container for other objects
]]--

function Layout(parameters)
	--Private
	local x = x or 1
	local y = y or 1
	local width = width or 10
	local height = height or 10
	local color = color or colors.white
	local transparent = transparent or false
	local xOffset = 0
	local yOffset = 0
	local finalX = xOffset + x
	local finalY = yOffset + y
	local children = {}
	local isActive = isActive == false and false or true
	local parent = {}
	local bindings = {}
	local application = {}
	--Public
	local self = {}
	function self.draw()
		if isActive  and (finalX <= 51 or finalX+width-1 >= 1) and (finalY <= 51 or finalY+height-1 >= 1) then
			if not transparent then
				paintutils.drawFilledBox(finalX,finalY,finalX+width-1,finalY+height-1,color)
			end
			for i,v in pairs(children) do
				for k,m in pairs(v) do
					m.setOffset(finalX-1,finalY-1)
					m.draw()
				end
			end
		end
	end
	function self.move(xNew,yNew)
		x = xNew
		y = yNew
		finalX = xOffset + x
		finalY = yOffset + y
	end
	function self.get(ser)
		return {
			x = x,
			y = y,
			width = width,
			height = height,
			color = color,
			transparent = transparent,
			isActive = isActive,
			children = children,
		}
	end
	function self.set(targs)
		x = targs.x or x
		y = targs.y or y
		width = targs.width or width
		height = targs.height or height
		color = targs.color or color
		transparent = targs.transparent or transparent
		children = targs.children or children
		isActive = targs.isActive or isActive
		finalX = xOffset + x
		finalY = yOffset + y
	end
	function self.setOffset(xOffsetT,yOffsetT)
		xOffset = xOffsetT
		yOffset = yOffsetT
		finalX = xOffset + x
		finalY = yOffset + y
	end
	self.type = "Layout"
	function self.event(e)
		if isActive then
			for i,v in pairs(children) do
				for k,m in pairs(v) do
					m.event(e)
				end
			end
		end
	end
	function self.setParent(par)
		parent = par
	end
	function self.setApplication(app)
		application = app
	end
	function self.callParent(method,...)
		parent[method](...)
	end
	function self.callApplication(method,...)
		(application or parent)[method](...)
	end
	function self.addChild(kid)
		local typ = kid.type
		if not children[typ] then
			children[typ] = {}
		end
		children[typ][#children[typ]+1] = kid
		children[typ][#children[typ]].setParent(self)
		children[typ][#children[typ]].setApplication(parent)
		if children[typ][#children[typ]].setBindings then
			children[typ][#children[typ]].setBindings(bindings)
		end
	end
	function self.setBindings(b)
		bindings = b
	end
	function self.verticalScroll(percentage)
		local offset = percentage*(height-({term.getSize()})[2])*(-1)
		finalY = offset + y
		for i,v in pairs(children) do
			for k,m in pairs(v) do
				m.setOffset(finalX-1,finalY-1)
			end
		end
		self.draw()
	end
	--Constructor
	self.set(parameters)
	return self
end

--[[
	Name: Menu
	Author: Wassil Janssen a.k.a. Creator
	Licence: GNU GENERAL PUBLIC LICENSE
	Description: A drop down with out a scrollbar.
]]--
--[[
	Item structure:
	1. clickable
	{
		type = "clickable",
		onRightClick = function,
		onLeftClick = function,
		text = text
		shortcut = number key
		shText = text
	}
	2. separator
	{
		type = "separator"
		char = aChar
	}
]]--

function Menu()
	--Private
	local x = 1
	local y = 1
	local text = ""
	local width = 3
	local bgColor = 1
	local textColor = 1
	local xOffset = 0
	local yOffset = 0
	local finalX = xOffset + x
	local finalY = yOffset + y
	local bindings = {}
	local items = {}
	local onRightClick
	local itemBg = 1
	local itemTxt = 1
	local doRun = true
	local parent = {}
	
	--Public
	local self = {}
	function self.draw()
		term.setCursorPos(finalX,finalY)
		term.setBackgroundColor(bgColor)
		term.setTextColor(textColor)
		term.write(" "..text.." ")
	end
	function self.move(xNew,yNew)
		x = xNew
		y = yNew
		finalX = xOffset + x
		finalY = yOffset + y
	end
	function self.get(ser)
		return {
			x = x,
			y = y,
			text = text,
			textColor = textColor,
			bgColor = bgColor,
			items = items,
			onRightClick = onRightClick,
			itemBg = itemBg,
			itemTxt = itemTxt,
		}
	end
	function self.set(targs)
		x = targs.x or x
		y = targs.y or y
		text = targs.text or text
		textColor = targs.textColor or textColor
		bgColor = targs.bgColor or bgColor
		items = targs.items or items
		onRightClick = targs.onRightClick or onRightClick
		finalX = xOffset + x
		finalY = yOffset + y
		itemBg = targs.itemBg or itemBg
		itemTxt = targs.itemTxt or itemTxt
		width = #text+2
	end
	function self.setOffset(xOffsetT,yOffsetT)
		xOffset = xOffsetT
		yOffset = yOffsetT
		finalX = xOffset + x
		finalY = yOffset + y
	end
	self.type = "Menu"
	self.canRun = true
	function self.event(e)
		if e[1] == "mouse_click" then
			if e[4] == finalY and finalX+1 <= e[3] and e[3] <= finalX+width-2 then
				if e[2] == 1 then
					self.run()
				elseif e[2] == 2 then
					onRightClick(self,e)
				end
			end
		end
	end
	function self.setBindings(b)
		bindings = b
	end
	function self.getWidth()
		return 2+#text
	end
	function self.run()
		local e = {}
		doRun = true
		local  size = 3
		local localx = 0
		tx = term.getSize()
		for i,v in pairs(items) do
			if v.type == "clickable" then
				local bu = #v.text + #v.shText + 1
				if bu > size then
					size = bu
				end
				bu = nil
			end
		end
		localx = finalX+size-1 <= tx and finalX or tx - (bu+2)
		while doRun do
			term.setBackgroundColor(itemBg)
			term.setTextColor(itemTxt)
			for i,v in pairs(items) do
				term.setCursorPos(localx,finalY+i)
				if v.type == "clickable" then
					term.write(" "..v.text..string.rep(" ",size-#v.text-#v.shText)..v.shText.." ")
				elseif v.type == "separator" then
					term.write(" "..string.rep(v.char,size).." ")
				end
			end
			term.setCursorPos(localx,finalY+#items+1)
			term.write(string.rep(" ",size+2))
			e = {os.pullEvent()}
			if bindings[e[1]] then
				for i,v in pairs(bindings[e[1]]) do
					v()
				end
			end
			if e[1] == "mouse_click" then
				if localx <= e[3] and e[3] <= localx+size+2 and finalY+1 <= e[4] and e[4] <= finalY+#items+1 then
					if localx+1 <= e[3] and e[3] <= localx+size-2  and e[4] <= finalY+#items then
						local obj = items[e[4]-finalY]
						if obj.type == "clickable" then
							if e[2]==1 then
								obj.onLeftClick(self)
							elseif e[2] == 2 then
								obj.onRightClick(self)
							end
						end
					end
				else
					doRun = false
				end
			elseif e[1] == "key" then
				for i,obj in pairs(items) do
					if obj.type == "clickable" then
						if obj.shortcut == e[2] then
							obj.onLeftClick(self)
						end
					end
				end
			end
			if bindings[e[1]] then
				for i,v in pairs(bindings[e[1]]) do
					v(e)
				end
			end
		end
	end
	function self.setParent(par)
		parent = par
	end
	function self.callParent(method,...)
		parent[method](...)
	end
	function self.quit()
		doRun = false
	end
	return self
end



--[[
	Name: Screen
	Author: Wassil Janssen a.k.a. Creator
	Licence: GNU GENERAL PUBLIC LICENSE
	Description: An objects that holds the layouts drawn to the screen.
]]--

function Screen(parameters)
	--Private
	local layout = {}
	local Application = {}
	local function runThreads() end
	local onEvent = {}
	--Public
	local self = {}
	local parent = {}

	self.type = "Screen"
	function self.setApplication(app)
		Application = app
	end
	function self.runThreads(func)
		runThreads = func
	end
	function self.event(event)
		if onEvent[event[1]] then
			for i,v in pairs(onEvent[event[1]]) do
				v(self,event)
			end
		end
		term.redirect(parent)
		layout.event(event)
		term.redirect(term.native())
	end
	function self.setLayout(lay)
		layout = lay
	end
	function self.addEvent(event,handle)
		if not onEvent[event] then
			onEvent[event] = {handle}
		else
			onEvent[event][#onEvent[event]] = handle
		end
	end
	function self.setParent(par)
		parent = par
	end
	function self.draw()
		if layout.draw then
			layout.draw()
		end
	end
	function self.set(tabl)
		tabl = type(tabl) == "table" and tabl or {}
		layout = tabl.layout or layout
	end
	--Constructor
	self.set(parameters)

	return self
end

--[[
	Name: TextBox
	Author: Wassil Janssen a.k.a. Creator
	Licence: GNU GENERAL PUBLIC LICENSE
	Description: A textBox, mate
]]--

function TextBox(args)
	--Private
	local self = {}
	local scroll = 0
	local x = 1
	local y = 1
	local bgColor = 1
	local textColor = 2
	local helpTextColor = 4
	local width = 5
	local height = 1
	local helpText = ""
	local text = ""
	local bindings = {}
	local parent = {}
	local application = {}
	local xOffset = 0
	local yOffset = 0
	local finalX = xOffset + x
	local finalY = yOffset + y
	local wrapped = {}
	local SB = VerticalScrollBar({
		x = x+width-1,
		y = y,
		parent = self,
		height = height,
		totalHeight = #wrapped, --IDK
		bgColor = bgColor,
		fgColor = textColor,
		bgButton = fgColor,
		fgButton = bgColor,
		percentage = 0,
		update = self.verticalScroll or function() end,
		bindings = bindings,
		interval = 100/(#wrapped-height),
	})
	local function wordWrap(help)
		local actualWidth = width-1
		local lines = {}
		local line = 1
		local pos = 1
		local rest = help == true and helpText or text 
		while true do
			local currText = rest:sub(1,actualWidth)
			if #currText < actualWidth then
				lines[line] = currText
				return lines
			end
			local start = currText:find("\n")
			if start then
				lines[line] = rest:sub(1,start-1)
				line = line+1
				rest = rest:sub(start+1,-1)
			elseif currText:find("%s") then
				local hasHappened = false
				for i=#currText,1,-1 do
					if currText:sub(i,i) == " " and not hasHappened then
						lines[line] = currText:sub(1,i)
						rest = rest:sub(i+1,-1)
						line = line+1
						hasHappened = true
					end
				end
			else
				lines[line] = currText
				rest = rest:sub(#currText+1,-1)
				line = line+1
			end
		end
	end
	local function isOnScreen()
		local termWidth, termHeight = term.getSize()
		if x+width-1 >= 1 or y+height-1 >= 1 or x <= termWidth or y <= termHeight then
			return true
		end
		return false
	end
	--Public
	function self.draw()
		if isOnScreen() then
			wrapped = wordWrap()
			paintutils.drawFilledBox(finalX,finalY,finalX+width-2,finalY+height-1,bgColor)
			SB.draw()
			term.setTextColor(textColor)
			term.setBackgroundColor(bgColor)
			if text == "" then
				helpTextWrapped = wordWrap(true)
				term.setCursorPos(finalX,finalY)
				term.setTextColor(helpTextColor)
				for i,v in pairs(helpTextWrapped) do
					local pos = i+y-1
					if y <= pos and pos <= y+height-1 then
						term.setCursorPos(x,pos)
						term.write(v)
					end
				end
			else
				for i,v in pairs(wrapped) do
					local pos = i+y-1+scroll
					if y <= pos and pos <= y+height-1 then
						term.setCursorPos(x,pos)
						term.write(v)
					end
				end
			end
		end
	end
	function self.move(xNew,yNew)
		x = xNew
		y = yNew
		finalX = xOffset + x
		finalY = yOffset + y
	end
	function self.get(ser)
		return {
			x = x,
			y = y,
			bgColor = bgColor,
			textColor = textColor,
			helpTextColor = helpTextColor,
			width = width,
			height = height,
			helpText = helpText,
			text = text,
			bindings = bindings,
			parent = parent,
			application = application,
		}
	end
	function self.set(targs)
		x = targs.x or x
		y = targs.y or y
		bgColor = targs.bgColor or bgColor
		textColor = targs.textColor or textColor
		helpTextColor = targs.helpTextColor or helpTextColor
		width = targs.width or width
		height = targs.height or height
		helpText = targs.helpText or helpText
		text = targs.text or text
		if targs.text then
			wrapped = wordWrap()
		end
		bindings = targs.bindings or bindings
		parent = targs.parent or parent
		application = targs.application or application
		finalX = xOffset + x
		finalY = yOffset + y
		SB.set({
			x = x+width-1,
			y = y,
			parent = self,
			height = height,
			totalHeight = #wrapped, --IDK
			bgColor = bgColor,
			fgColor = textColor,
			bgButton = textColor,
			fgButton = bgColor,
			percentage = 0,
			update = self.verticalScroll,
			bindings = bindings,
			interval = 100/(#wrapped-height),
		})
	end
	function self.setOffset(xOffsetT,yOffsetT)
		xOffset = xOffsetT
		yOffset = yOffsetT
		finalX = xOffset + x
		finalY = yOffset + y
	end
	self.type = ""
	function self.event(event)
		if event[1] == "mouse_click" then
			if x <= event[3] and event[3] <= x+width-1 and y <= event[4] and event[4] <= y+height-1 then
				if event[3] == x+width-1 then
					SB.event(event)
				else
					self.run()
				end
			end
		end
	end
	function self.run()
		local cursorXY={1,1}
		local textPos = #text
		while true do
			wrapped = wordWrap()
			SB.set({
				interval = 100/(#wrapped-height),
				totalHeight = #wrapped,
			})
			SB.draw()
			self.draw()
			local event = {coroutine.yield()}
			if event[1] == "key" then
				if event[2] == 28 then --Enter

				elseif event[2] == 205 then --Right
					textPos = textPos+1
					if textPos > #text then textPos = #text end
				elseif event[2] == 203 then --Left
					textPos = textPos-1
					if textPos < 0 then textPos = 0 end
				elseif event[2] == 200 then --Up

				elseif event[2] == 208 then --Down

				elseif event[2] == 15 then --Tab

				elseif event[2] == 14 then --Backspace
					text = text:sub(0,textPos-1)..text:sub(textPos+1)
					textPos = textPos-1
				elseif event[2] == 211 then
					text = text:sub(0,textPos)..text:sub(textPos+2)
				elseif event[2] == 28 then --Enter
					text = text:sub(0,textPos).."\n"..text:sub(textPos+1)
					textPos = textPos+1
				end
			elseif event[1] == "char" then
				text = text:sub(0,textPos)..event[2]..text:sub(textPos+1)
				textPos = textPos+1
			elseif event[1] == "mouse_click" then
				if x <= event[3] and event[3] <= x+width-1 and y <= event[4] and event[4] <= y+height-1 then

				else
					break
				end
			end
		end
	end
	function self.setParent(par)
		parent = par
	end
	function self.setApplication(app)
		application = app
	end
	function self.verticalScroll(percentage)

	end
	--Constructor
	self.set(args)
	return self
end



--[[
	Name: VerticalScrollBar
	Author: Wassil Janssen a.k.a. Creator
	Licence: GNU GENERAL PUBLIC LICENSE
	Description: A scrollbar
]]--

function VerticalScrollBar(parameters)
	--Private
	local x = x or 1
	local y = y or 1
	local parent = {}
	local xOffset = 0
	local yOffset = 0
	local finalX = xOffset + x
	local finalY = yOffset + y
	local height = 3
	local application = {}
	local totalHeight = 5
	local bgColor = 1
	local fgColor = 1
	local bgButton = 2
	local fgButton = 4
	local percentage = 0
	local update = function() end
	local size = 1
	local pos = 1
	local bindings = {}
	local interval = 1
	--Public
	local self = {}
	function self.draw()
		term.setCursorPos(x,y)
		term.setBackgroundColor(bgButton)
		term.setTextColor(fgButton)
		term.write("^")
		term.setCursorPos(x,y+height-1)
		term.write("v")
		paintutils.drawLine(x,y+1,x,y+height-2,bgColor)
		if totalHeight > height then
			paintutils.drawLine(x,y+pos+1,x,y+pos+size,fgColor)
		end
	end
	function self.get()
		return {
			x = x,
			y = y,
			parent = parent,
			height = height,
			totalHeight = totalHeight,
			bgColor = bgColor,
			fgColor = fgColor,
			bgButton = bgButton,
			fgButton = fgButton,
			percentage = percentage,
			update = update,
			bindings = bindings,
			interval = interval,
		}
	end
	function self.set(targs)
		x = targs.x or x
		y = targs.y or y
		parent = targs.parent or parent
		height = targs.height or height
		totalHeight = targs.totalHeight or totalHeight
		bgColor = targs.bgColor or bgColor
		fgColor = targs.fgColor or fgColor
		bgButton = targs.bgButton or bgButton
		fgButton = targs.fgButton or fgButton
		percentage = targs.percentage or percentage
		update = targs.update or update
		bindings = targs.bindings or bindings
		finalX = xOffset + x
		finalY = yOffset + y
		interval = targs.interval or interval
		size = math.floor(height*height/totalHeight)
		pos = math.abs(math.ceil(percentage*(height-(size+2))/100))
	end
	function self.setOffset(xOffsetT,yOffsetT)
		xOffset = xOffsetT
		yOffset = yOffsetT
		finalX = xOffset + x
		finalY = yOffset + y
	end
	self.type = ""
	function self.event(event)
		if not (totalHeight > height) then return end
		if event[1] == "mouse_click" and event[2] == 1 then
			if event[3] == x then
				if y <= event[4] and event[4] <= y+height-1 then
					if event[4] == y then
						percentage = percentage - interval
						if percentage < 0 then
							percentage = 0
						end
						update(percentage/100)
					elseif event[4] == y+height-1 then
						percentage = percentage + interval
						if percentage > 100 then
							percentage = 100
						end
						update(percentage/100)
					else
						if y+pos+1 <= event[4] and event[4] <= y+pos+size then
							self.run(event[4])
						else
							local e4 = event[4] - math.floor(size/2)
							local per = e4/((height-(size+2))/100)
							percentage = per - per%interval
							if percentage > 100 then
								percentage = 100
							elseif percentage < 0 then
								percentage = 0
							end
							update(percentage/100)
						end
					end
				end
			end
		end
	end
	function self.run(y)
		local prevY = y
		while true do
			local event = {os.pullEvent()}
			if event[1] == "mouse_click" then
				if event[3] == x and y <= event[4] and event[4] <= y+height-1 then
					self.event(event)
				else
					if application.event then
						application.event(event)
						break
					elseif parent.event then
						parent.event(event)
						break
					else
						break
					end
				end
			elseif event[1] == "mouse_drag" then
				local diff = event[4] - prevY
				prevY = event[4] 
				local per = (pos+diff)/((height-(size+2))/100)
				percentage = per - per%interval
				if percentage > 100 then
					percentage = 100
				elseif percentage < 0 then
					percentage = 0
				end
				self.draw()
				update(percentage/100)
			end
			if bindings[event[1]] then
				for i,v in pairs(bindings[event[1]]) do
					v()
				end
			end
		end
	end
	function self.setParent(par)
		parent = par
	end
	function self.callParent(method,...)
		if parent[method] then
			parent[method](...)
		end
	end
	function self.callApplication(method,...)
		if application[method] then
			application[method](...)
		end
	end
	function self.setBindings(bin)
		bindings = bin
	end
	function self.setApplication(app)
		application = app
	end
	self.type = "VerticalScrollBar"
	--Constructor
	self.set(parameters or {})
	return self
end